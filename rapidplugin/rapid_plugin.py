# Copyright 2020 Software Improvement Group
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from rapidplugin.kafka_non_blocking import KafkaPluginNonBlocking
from rapidplugin.analysis.lizard_analyzer import LizardAnalyzer
from rapidplugin.utils.utils import MavenUtils, KafkaUtils


class RapidPlugin(KafkaPluginNonBlocking):
    '''
    This main class handles consuming from Kafka, executing code analysis, 
    and producing the resulting payload back into a Kafka topic.
    '''

    def __init__(self, name, version, description, plugin_config):
        self._name = name
        self._version = version
        self._description = description
        self.plugin_config = plugin_config
        super().__init__(self.plugin_config.get_config_value('bootstrap_servers'))
        self.consume_topic = self.plugin_config.get_config_value('consume_topic')
        self.produce_topic = self.plugin_config.get_config_value('produce_topic')
        self.log_topic = self.plugin_config.get_config_value('log_topic')
        self.error_topic = self.plugin_config.get_config_value('err_topic')
        self.group_id = self.plugin_config.get_config_value('group_id')
        self.sources_dir = self.plugin_config.get_config_value('sources_dir')
        self.consumer_timeout_ms = self.plugin_config.get_config_value('consumer_timeout_ms')
        self.set_consumer()
        self.set_producer()
        self.announce()

    def name(self):
        return self._name

    def version(self):
        return self._version

    def description(self):
        return self._description

    def announce(self):
        '''
        Announces the activation of this plugin instance to the log_topic.
        '''
        self.log_success(format(
            self.plugin_config.get_all_values()),
                         "Plugin active with configuration " +
                         "'" + self.plugin_config.get_config_name() + "'")

    def consume(self, record):
        '''
        Call-back method to handle a message on self.consume_topic.
        Parses the payload and passes on to the self.produce method for
        processing the provided coordinates.

        Arguments:
          record (JSON): message from self.consume_topic
        '''
        payload = record['payload'] if 'payload' in record else record
        in_payload = KafkaUtils.tailor_input(payload)
        try:
            KafkaUtils.validate_message(payload)
            self.log_success(in_payload, "Consumed message successfully.")
            self.produce(in_payload)
        except Exception as error:
            self.log_failure(in_payload, "Consume failed for message.", str(error))

    def produce(self, in_payload):
        '''
        Produces quality analysis results to the produce_topic. A separate
        message will be emitted for each payload generated by the analyzer.

        Arguments:
          in_payload (JSON): validated source code location
        '''
        try:
            analyzer = LizardAnalyzer(self.sources_dir)
            out_payloads = analyzer.analyze(in_payload)
            for out_payload in out_payloads:
                self.produce_payload(in_payload, out_payload)
            self.log_success(in_payload, "Produced quality analysis results.")
        except Exception as error:
            self.log_failure(in_payload, "Produce failed for payload.", str(error))

    def produce_payload(self, in_payload, out_payload):
        out_message = self.create_message(in_payload, {"payload": out_payload})
        self.emit_message(self.produce_topic, out_message, "[SUCCESS]", out_message)

    def log_failure(self, in_payload, failure, error):
        '''
        Log a failure and the underlying error to the appropriate topics.

        Arguments:
          in_payload (JSON): The consumed message for which the failure happened.
          failure (str)    : Description of what failed.
          error (str)      : Description of the underlying error (exception).
        '''
        log_message = self.create_message(in_payload, {"status": "FAILURE",
                                                       "failure": failure})
        self.emit_message(self.log_topic, log_message, "[FAILURE]", failure)
        err_message = self.create_message(in_payload, {"error": error})
        self.emit_message(self.error_topic, err_message, "[ERROR]", err_message)

    def log_success(self, in_payload, success):
        '''
        Log a success to the appropriate topics.

        Arguments:
          in_payload (JSON): The consumed message for which the success happened.
        '''
        log_message = self.create_message(in_payload, {"status": "SUCCESS",
                                                       "success": success})
        self.emit_message(self.log_topic, log_message, "[SUCCESS]", log_message)

    def free_resource(self):
        if self.consumer is not None:
            self.consumer.close()
        if self.producer is not None:
            self.producer.close()
